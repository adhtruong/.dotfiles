#!/usr/bin/env bash

# Git worktree manager - both interactive and CLI modes
# Usage:
#   worktree           # Interactive UI
#   worktree add <branch>    # Add worktree
#   worktree remove <path>   # Remove worktree
#   worktree list            # List worktrees (for scripting)

set -euo pipefail

usage() {
	cat <<EOF
Usage: worktree [COMMAND] [ARGS]

Commands:
    (no args)           Open interactive worktree manager
    add <branch>        Create new worktree for branch
    remove <path>       Remove worktree at path
    list                List worktrees (paths only, for scripting)
    -h, --help          Show this help

Examples:
    worktree
    worktree add feature-login
    worktree remove /path/to/worktree
    worktree list | xargs -I{} git -C {} status
EOF
}

check_git_repo() {
	git rev-parse --git-dir >/dev/null 2>&1
}

get_repo_root() {
	git worktree list | head -1 | awk '{print $1}'
}

get_default_branch() {
	local ref
	ref=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null) && echo "${ref##refs/remotes/origin/}" || echo "main"
}

cleanup_after_remove() {
	git delete-squashed >/dev/null 2>&1 || true
	tmux-clean >/dev/null 2>&1 || true
}

add_worktree() {
	local branch_name="$1"

	if [[ -z "$branch_name" ]]; then
		echo "Error: Branch name cannot be empty"
		return 1
	fi

	# Validate branch name (no spaces or special chars except - _ /)
	if [[ ! "$branch_name" =~ ^[a-zA-Z0-9/_-]+$ ]]; then
		echo "Error: Invalid branch name '$branch_name' (use alphanumeric, -, _, /)"
		return 1
	fi

	local repo_root
	repo_root=$(get_repo_root)
	local worktree_path="$repo_root-features/$branch_name"

	if [[ -d "$worktree_path" ]]; then
		echo "Error: Worktree already exists at $worktree_path"
		return 1
	fi

	local output
	# Try to create worktree with new branch first
	if output=$(git worktree add -b "$branch_name" "$worktree_path" 2>&1); then
		echo "Created worktree '$branch_name' at $worktree_path"
		return 0
	fi

	# If branch exists, try using existing branch
	if output=$(git worktree add "$worktree_path" "$branch_name" 2>&1); then
		echo "Created worktree for existing branch '$branch_name' at $worktree_path"
		return 0
	fi

	# Show actual error
	echo "Error: Failed to create worktree '$branch_name'"
	echo "$output" | head -3
	return 1
}

remove_worktree() {
	local worktree_path="$1"

	if [[ -z "$worktree_path" ]]; then
		echo "Error: Worktree path cannot be empty"
		return 1
	fi

	# Change to repo root first (can't remove worktree while inside it)
	local repo_root
	repo_root=$(get_repo_root)

	local output
	if output=$(git -C "$repo_root" worktree remove -f "$worktree_path" 2>&1); then
		echo "Removed worktree: $worktree_path"
		cleanup_after_remove
		return 0
	fi

	echo "Error: Failed to remove worktree '$worktree_path'"
	echo "$output" | head -3
	return 1
}

list_worktrees() {
	git worktree list --porcelain | awk '/^worktree / {print $2}'
}

interactive_mode() {
	if ! check_git_repo; then
		return 1
	fi

	local repo_root
	repo_root=$(get_repo_root)

	local selected
	selected=$(git worktree list | fzf \
		--ansi \
		--border-label 'ðŸŒ´ Worktrees ' \
		--header 'CTRL-X (remove) : CTRL-A (add) : ENTER (connect)' \
		--bind "ctrl-x:reload(worktree remove {1} >/dev/null; git -C '$repo_root' worktree list)" \
		--bind "ctrl-a:reload(worktree add {q} >/dev/null; git -C '$repo_root' worktree list)" \
		--preview "$(
			cat <<'PREVIEW'
			path={1}
			echo -e '\033[1;36mðŸ“ Worktree:\033[0m '"$path"
			echo

			# Show branch with ahead/behind info
			branch=$(git -C "$path" branch --show-current 2>/dev/null)
			ref=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null) && default="${ref##refs/remotes/origin/}" || default="main"
			if [[ -n "$branch" ]]; then
				ahead=$(git -C "$path" rev-list --count "origin/$default..$branch" 2>/dev/null || echo 0)
				behind=$(git -C "$path" rev-list --count "$branch..origin/$default" 2>/dev/null || echo 0)
				status=""
				[[ "$ahead" -gt 0 ]] && status+="â†‘$ahead "
				[[ "$behind" -gt 0 ]] && status+="â†“$behind"
				echo -e "\033[1;32mðŸŒ¿ Branch:\033[0m $branch ${status:+\033[1;33m[$status]\033[0m}"
			fi

			# Dirty indicator
			if [[ -n $(git -C "$path" status --porcelain 2>/dev/null) ]]; then
				echo -e '\033[1;31mâš   Uncommitted changes\033[0m'
			fi
			echo

			echo -e '\033[1;33mðŸ“Š Status:\033[0m'
			git -C "$path" -c color.status=always status --short --branch 2>/dev/null
			echo

			echo -e '\033[1;35mðŸ“œ Recent Commits:\033[0m'
			git -C "$path" log --oneline --graph --date=short --color=always --pretty='format:%C(auto)%cd %h%d %s' -10 2>/dev/null
PREVIEW
		)") || return 0

	if [[ -n "$selected" ]]; then
		local worktree_path
		worktree_path=$(echo "$selected" | awk '{print $1}')
		sesh connect "$worktree_path"
	fi
}

main() {
	case "${1:-}" in
	-h | --help)
		usage
		exit 0
		;;
	add)
		check_git_repo || {
			echo "Error: Not a git repository"
			exit 1
		}
		add_worktree "${2:-}"
		;;
	remove)
		check_git_repo || {
			echo "Error: Not a git repository"
			exit 1
		}
		remove_worktree "${2:-}"
		;;
	list)
		check_git_repo || {
			echo "Error: Not a git repository"
			exit 1
		}
		list_worktrees
		;;
	"")
		interactive_mode
		;;
	*)
		echo "Error: Unknown command '$1'"
		echo ""
		usage
		exit 1
		;;
	esac
}

main "$@"
